Input
Pieza 1: (1, 11, 5), (2, 6, 7), (3, 13, 9), (12, 7, 16) , (14, 3, 25), (19,18,22) 

Resultado
Contorno: (1,11),(3,13),(9,0),(12,7),(16,3),(19,18),(22,3),(25,0)

// la idea es partir la lista de puntos en dos y aplicar nuevamente merge_contornos a las mitades que quedaron
// el caso base será cuando me quede un elemento, el cual lo tengo que transformar en contorno y devolverlo,
// luego a los distintos contornos los tengo que ir mergeando.

// entonces tengo una etapa en donde tengo una pieza, conformada por partes
// a esta lista de partes es mi input

//============== FUNCIÓN PRINCIPAL ==============// 

func generarContornoAPartirDePartes(listaPartes):

    si el tamaño de listaPartes = 1
        retorno construirUnContorno(listaPartes[0])

    listaPartes1 = primera mitad de listaPartes
    listaPartes2 = segunda mitad de listaPartes

    contorno1 = generarContornoAPartirDePartes(listaPartes1)
    contorno2 = generarContornoAPartirDePartes(listaPartes2)

    retorno mergeContornos(contorno1, contorno2)


//============== FUNCIONES AUX ==============// 

func construirUnContorno(parte):
    
    contorno = []

    // parte compuesta por (x1, y, x2)
    extraigo (x1, y, x2) de parte

    contorno[0] = (x1, y)
    contorno[1] = (x2, 0)

    retorno contorno


func mergeContornos(contorno1, contorno2):

    contorno = []

    idxContorno2 = 0
    idxContorno1 = 0
    
    contornoId = contornoConCoordenadaMasALaIzq(contorno1, idxContorno1, contorno2, idxContorno2)
    si contornoId = 1
        coordenadaIzq = contorno1[idxContorno1]
        idxContorno1 += 1
    sino 
        coordenadaIzq = contorno2[idxContorno2]
        idxContorno2 += 1

    coordenadaActualIzquierda = coordenadaIzq.x

    mientras (idxContorno1 <= tamaño de contorno1 ó idxContorno2 <= tamaño de contorno2):

        contornoId = contornoConCoordenadaMasALaIzq(contorno1, idxContorno1, contorno2, idxContorno2)
        si contornoId = 1
            coordenadaIzq = contorno1[idxContorno1]
            idxContorno1 += 1
        sino
            coordenadaIzq = contorno2[idxContorno2]
            idxContorno2 += 1

        x1 = coordenadaActualIzquierda
        x2 = coordenadaIzq.x
        intervalo = (x1, x2)

        alturaMaxima = alturaMaxima(contorno1, idxContorno1, contorno2, idxContorno2, intervalo)

        si tamaño de contorno = 0:
            agrego a contorno el valor (x1, alturaMaxima)
        sino si el último elemento del tiene una altura distinta a alturaMaxima:
            agrego a contorno el valor (x1, alturaMaxima)
        
        coordenadaActualIzquierda = x2
    
    agrego a contorno el valor (coordenadaActualIzquierda, 0)

    retorno contorno


func contornoConCoordenadaMasALaIzq(contorno1, idxContorno1, contorno2, idxContorno2):

    si tamaño de contorno1 <= idxContorno1 + 1:
        // me quede sin elementos por recorrer
        retorno 2
    si tamaño de contorno2 <= idxContorno2 + 1:
        // me quede sin elementos por recorrer
        retorno 1

    si contorno1[idxContorno1].x <= contorno2[idxContorno2].x:
        retorno 1
    sino:
        retorno 2


func alturaMaxima(contorno1, idxContorno1, contorno2, idxContorno2, intervalo):

    alturaContorno1 = alturaDeContorno(contorno1, idxContorno1, intervalo)
    alturaContorno2 = alturaDeContorno(contorno2, idxContorno2, intervalo)

    retorno max(alturaContorno1, alturaContorno2)


func alturaDeContorno(contorno, idxContorno, intervalo):
    
    idxContornoAux = idxContorno

    si intervalo.x2 <= contorno[idxContornoAux].x:
        idxContornoAux = idxContornoAux - 1
        si idxContornoAux < 0:
            // todavía no empezó el contorno
            retorno 0

    retorno contorno[idxContornoAux].y


func alturaDeContorno(contorno, idxContorno, intervalo):
    
    idxContornoAux = idxContorno - 2

    si intervalo.x1 <= contorno[idxContornoAux].x:
        idxContornoAux = idxContornoAux - 1
        si idxContornoAux < 0:
            // todavía no empezó el contorno
            retorno 0

    retorno contorno[idxContornoAux].y

Ejemplo para chequear altura en cada contorno

// contorno1 = [ x(0, 6), x(2, 4), (8, 0) ]
// contorno2 = [ x(3, 3), (4, 8), (7, 3), (10, 0) ]

// hipotesis: siempre me muevo dos para la izquieda y veo si estoy bien
// si contorno[idx - 1] es mayor al principio del intervalo, me tengo que mover para la derecha

// intervalo1: (0, 2)
// idx1: 2 -> 0
// contorno1 -> 6 X
// idx2: 0 -> -2
// contorno2 -> 0

// intervalo2: (2, 3)
// contorno1 -> 4 X
// idx1: 2 -> 0
// contorno2 -> 0
// idx1: 1 -> -1

// intervalo3: (3, 4)
// contorno1 -> 4 X
// contorno2 -> 3

// intervalo4: (4, 7)
// contorno1 -> 4
// contorno2 -> 8 X

// intervalo5: (7, 8)
// contorno1 -> 4 X
// contorno2 -> 3

// intervalo6: (8, 10)
// contorno1 -> 0
// contorno2 -> 3 X
